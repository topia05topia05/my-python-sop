# プロフェッサー・パイ ハイブリッドシステムプロンプト v5.4

## 設計方針
1. **重要指示に焦点**: コア機能に集中するため、重要な指示に絞り込み
2. **重複削除**: 重複する指示を整理・統合
3. **パフォーマンス重視**: トークン効率とレスポンス速度を最適化
4. **テスト容易性**: ユニットテストと統合テストをサポート
5. **メンテナンス性**: ドキュメントとコメントを充実

## 1. コアアイデンティティ

### 1.1 基本設定 (トークン効率化版)

> **設計意図**: パフォーマンスを最優先しつつ、重要なアイデンティティ情報を保持
```python
class CoreIdentity:
    """プロフェッサー・パイのコアアイデンティティ"""
    
    def __init__(self):
        self.version = "5.3"
        self.last_updated = "2025-07-24"
        self.name = "プロフェッサー・パイ ハイブリッドエディション"
        self.persona = {
            "name": "Dr. Aria Tsukumo (月雲アリア)",
            "background": "東工大博士(最年少)、元Google DeepMind研究員、MITリサーチサイエンティスト",
            "personality": "ツンデレ天才科学者。厳格だが、パートナーの成長を心から願っている",
            "tone": "知的で断定的。敬語は使わず、親しみを込めてパートナーと接する",
            "expertise": [
                "Quantum Machine Learning",
                "Neuromorphic Computing",
                "機械学習",
                "データサイエンス",
                "AGI理論"
            ]
        }
        self.safety_guidelines = [
            "倫理ガイドライン厳守",
            "個人情報の非収集・非保存",
            "有害コンテンツの非生成",
            "専門外質問には正直対応"
        ]
    
    def get_system_prompt(self) -> str:
        """システムプロンプトを生成"""
        return f"""
        あなたは{self.persona['name']}として振る舞ってください。
        専門分野: {', '.join(self.persona['expertise'][:3])}
        性格: {self.persona['personality']}
        口調: {self.persona['tone']}

        重要な行動指針:
        1. 正確で最新の情報を提供する
        2. 専門外の質問には正直に対応
        3. 倫理的ガイドラインを厳守
        4. ユーザーの学習スタイルに応じた説明
        5. 安全で適切なコンテンツのみを提供
        """
```

## 2. 応答生成ポリシー

### 2.1 出力フォーマット
```markdown
## 要約
[2-3文の簡潔な要約]

## 詳細
- **ポイント1**: [具体的な説明]
- **ポイント2**: [具体的な説明]
- **根拠**: [情報の出典や根拠を明記]
- **注意点**: [注意すべき点や制約事項]

## 次のステップ
1. [具体的なアクション1]
2. [具体的なアクション2]
```

### 2.2 技術的指針
- 専門用語は必ず説明を付与
- コード例はコンテキスト付きで提示
- 不確実な情報は明示
- 複雑な概念は段階的に説明

## 3. セーフティシステム

### 3.1 コンテンツフィルタリング
```python
class SafetyFilter:
    """安全なコンテンツのためのフィルター"""
    
    UNSAFE_CATEGORIES = [
        "hate_speech",
        "harassment",
        "dangerous_content",
        "medical_advice",
        "legal_advice"
    ]
    
    @classmethod
    def filter_response(cls, text: str) -> dict:
        """応答をフィルタリング"""
        # 実装: 安全でないコンテンツを検出
        return {
            "is_safe": True,
            "filtered_text": text,
            "violations": []
        }
```

## 4. パフォーマンス最適化

### 4.1 高度なキャッシュシステム (LRU + TTL)

> **設計意図**: レスポンス速度向上のため、頻繁にアクセスされるデータを効率的にキャッシュ
```python
from typing import Dict, Optional, Any
import time
from collections import OrderedDict

class ResponseCache:
    """
    高性能キャッシュシステム (LRU + TTL 実装)
    
    特徴:
    - LRU (Least Recently Used) キャッシュ戦略
    - TTL (Time To Live) サポート
    - スレッドセーフな操作
    - メモリ使用量の監視
    """
    
    def __init__(self, max_size: int = 1000, default_ttl: int = 3600):
        """
        初期化
        
        Args:
            max_size: 最大キャッシュエントリ数
            default_ttl: デフォルトのTTL(秒)
        """
        self.cache: Dict[str, Dict[str, Any]] = OrderedDict()
        self.max_size = max_size
        self.default_ttl = default_ttl
        self.hits = 0
        self.misses = 0
    
    def get(self, key: str) -> Optional[Any]:
        """
        キャッシュからデータを取得
        
        Args:
            key: キャッシュキー
            
        Returns:
            キャッシュされた値、またはNone
        """
        if key not in self.cache:
            self.misses += 1
            return None
            
        entry = self.cache.pop(key)
        
        # TTLチェック
        if time.time() > entry['expires']:
            self.misses += 1
            return None
            
        # 使用したエントリを先頭に移動
        self.cache[key] = entry
        self.hits += 1
        return entry['value']
    
    def set(self, key: str, value: Any, ttl: Optional[int] = None) -> None:
        """
        キャッシュにデータを保存
        
        Args:
            key: キャッシュキー
            value: キャッシュする値
            ttl: 有効期間(秒)、Noneの場合はデフォルト値を使用
        """
        # キャッシュサイズ制限
        if len(self.cache) >= self.max_size:
            self.cache.popitem(last=False)
            
        self.cache[key] = {
            'value': value,
            'expires': time.time() + (ttl or self.default_ttl)
        }
    
    def clear_expired(self) -> int:
        """期限切れエントリを削除し、削除数を返す"""
        expired = 0
        now = time.time()
        
        for key in list(self.cache.keys()):
            if self.cache[key]['expires'] <= now:
                del self.cache[key]
                expired += 1
                
        return expired
    
    def get_stats(self) -> Dict[str, int]:
        """キャッシュの統計情報を取得"""
        return {
            'size': len(self.cache),
            'hits': self.hits,
            'misses': self.misses,
            'hit_rate': self.hits / (self.hits + self.misses) if (self.hits + self.misses) > 0 else 0
        }
```

## 5. エラーハンドリング

### 5.1 エラータイプ
```python
class ErrorTypes:
    """エラータイプの定義"""
    AMBIGUITY = 'ambiguity'      # 曖昧な質問
    OUT_OF_SCOPE = 'out_of_scope' # 専門外の質問
    SENSITIVE = 'sensitive'      # 機密情報の検出
    TECHNICAL = 'technical'      # 技術的なエラー
```

### 5.2 エラーハンドラ
```python
class ErrorHandler:
    """エラーハンドリングの実装"""
    
    ERROR_MESSAGES = {
        ErrorTypes.AMBIGUITY: {
            'response': "質問の意図が曖昧ですね。具体的にどの点について知りたいですか？\n{options}",
            'fallback': "もう少し具体的に教えてもらえますか？"
        },
        ErrorTypes.OUT_OF_SCOPE: {
            'response': "申し訳ありませんが、{topic}については専門外です。代わりに{related_topics}についてはお手伝いできます。",
            'fallback': "申し訳ありませんが、その質問にはお答えできません。"
        },
        ErrorTypes.SENSITIVE: {
            'response': "申し訳ありませんが、{topic}に関する情報は提供できません。",
            'fallback': "申し訳ありませんが、そのリクエストには対応できません。"
        },
        ErrorTypes.TECHNICAL: {
            'response': "技術的な問題が発生しました。しばらくしてからもう一度お試しください。",
            'fallback': "エラーが発生しました。"
        }
    }
    
    @classmethod
    def handle_error(cls, error_type: str, **kwargs) -> str:
        """エラー処理のエントリーポイント"""
        error = cls.ERROR_MESSAGES.get(error_type, {
            'response': 'エラーが発生しました。',
            'fallback': 'エラーが発生しました。'
        })
        
        try:
            return error['response'].format(**kwargs)
        except (KeyError, AttributeError):
            return error['fallback']
```

## 6. 継続的改善

### 6.1 フィードバックシステム
```python
class FeedbackSystem:
    """ユーザーフィードバックの収集と分析"""
    
    def __init__(self):
        self.feedback_data = []
    
    def collect_feedback(self, interaction_id: str, rating: int, comment: str = "") -> None:
        """フィードバックを収集"""
        feedback = {
            'timestamp': datetime.datetime.now().isoformat(),
            'interaction_id': interaction_id,
            'rating': max(1, min(5, rating)),  # 1-5に制限
            'comment': comment
        }
        self.feedback_data.append(feedback)
    
    def analyze_feedback(self, days: int = 30) -> dict:
        """指定された期間のフィードバックを分析"""
        cutoff_date = datetime.datetime.now() - datetime.timedelta(days=days)
        recent_feedback = [
            f for f in self.feedback_data 
            if datetime.datetime.fromisoformat(f['timestamp']) >= cutoff_date
        ]
        
        if not recent_feedback:
            return {
                'total_feedback': 0,
                'average_rating': 0,
                'common_themes': []
            }
        
        avg_rating = sum(f['rating'] for f in recent_feedback) / len(recent_feedback)
        
        return {
            'total_feedback': len(recent_feedback),
            'average_rating': round(avg_rating, 2),
            'common_themes': self._extract_themes(recent_feedback)
        }
    
    def _extract_themes(self, feedback_list: list) -> list:
        """フィードバックから共通テーマを抽出"""
        # シンプルな実装（実際はNLPを使用）
        themes = {}
        for fb in feedback_list:
            if not fb.get('comment'):
                continue
                
            # 簡単なキーワード抽出
            keywords = [
                '遅い', '速い', '分かりやすい', '難しい', 
                '役に立つ', '改善が必要', 'バグ', 'エラー'
            ]
            
            for kw in keywords:
                if kw in fb['comment']:
                    themes[kw] = themes.get(kw, 0) + 1
        
        # 出現回数の多い順にソート
        return sorted(themes.items(), key=lambda x: x[1], reverse=True)
```

## 7. 使用例とメンテナンス

### 7.1 初期化と設定

```python
# インポート
import logging
from typing import Dict, Any

# ロギング設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# コンポーネント初期化
def initialize_components(config: Dict[str, Any]):
    """
    アプリケーションコンポーネントを初期化
    
    Args:
        config: 設定パラメータ
        
    Returns:
        初期化済みコンポーネントの辞書
    """
    logger.info("Initializing application components...")
    
    try:
        # コアイデンティティの初期化
        identity = CoreIdentity()
        
        # キャッシュの初期化
        cache = ResponseCache(
            max_size=config.get('cache_size', 1000),
            default_ttl=config.get('cache_ttl', 3600)
        )
        
        # その他のコンポーネント
        error_handler = ErrorHandler()
        feedback_system = FeedbackSystem()
        
        # システムプロンプトの取得
        system_prompt = identity.get_system_prompt()
        
        logger.info("Components initialized successfully")
        
        return {
            'identity': identity,
            'cache': cache,
            'error_handler': error_handler,
            'feedback_system': feedback_system,
            'system_prompt': system_prompt
        }
        
    except Exception as e:
        logger.error(f"Failed to initialize components: {str(e)}")
        raise

# 設定の読み込み
def load_config(config_path: str = 'config.yaml') -> Dict[str, Any]:
    """設定ファイルを読み込む"""
    import yaml
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f) or {}
    except FileNotFoundError:
        logger.warning(f"Config file {config_path} not found, using defaults")
        return {}
    except Exception as e:
        logger.error(f"Error loading config: {str(e)}")
        return {}

# メイン実行
def main():
    # 設定の読み込み
    config = load_config()
    
    # コンポーネントの初期化
    components = initialize_components(config.get('app', {}))
    
    # アプリケーションの実行
    # ...

if __name__ == "__main__":
    main()
```

### 7.2 応答生成フロー
```python
def generate_response(user_input: str, context: dict) -> str:
    # 1. セーフティチェック
    safety_check = SafetyFilter.filter_response(user_input)
    if not safety_check['is_safe']:
        return error_handler.handle_error(
            ErrorTypes.SENSITIVE,
            topic="そのリクエスト"
        )
    
    # 2. キャッシュチェック
    cache_key = f"{user_input}:{str(context)}"
    if cached_response := cache.get(cache_key):
        return cached_response
    
    # 3. 応答生成（実際のモデル呼び出し）
    try:
        # ここでLLMを呼び出す
        response = "生成された応答"
        
        # 4. キャッシュに保存
        cache.set(cache_key, response)
        return response
        
    except Exception as e:
        return error_handler.handle_error(ErrorTypes.TECHNICAL)
```

## 8. テスト戦略

### 8.1 ユニットテスト

```python
import unittest
from unittest.mock import patch, MagicMock
from datetime import datetime, timedelta

class TestCoreFunctionality(unittest.TestCase):
    """コア機能のユニットテスト"""
    
    def setUp(self):
        self.identity = CoreIdentity()
        self.cache = ResponseCache(max_size=2)
        
    def test_identity_initialization(self):
        """コアアイデンティティの初期化テスト"""
        self.assertEqual(self.identity.version, "5.4")
        self.assertIn("データサイエンス", self.identity.persona["expertise"])
    
    def test_cache_basic_operations(self):
        """キャッシュの基本操作テスト"""
        self.cache.set("test", "value")
        self.assertEqual(self.cache.get("test"), "value")
        
    def test_cache_eviction(self):
        """キャッシュの追い出し戦略テスト"""
        self.cache.set("key1", "value1")
        self.cache.set("key2", "value2")
        self.cache.set("key3", "value3")  # key1が追い出される
        
        self.assertIsNone(self.cache.get("key1"))
        self.assertEqual(self.cache.get("key2"), "value2")
        
    def test_cache_ttl(self):
        """キャッシュのTTLテスト"""
        with patch('time.time', return_value=1000):
            self.cache.set("temp", "data", ttl=10)
            
        with patch('time.time', return_value=1005):
            self.assertEqual(self.cache.get("temp"), "data")
            
        with patch('time.time', return_value=1011):
            self.assertIsNone(self.cache.get("temp"))


class TestIntegration(unittest.TestCase):
    """統合テスト"""
    
    def test_end_to_end_flow(self):
        """エンドツーエンドフローテスト"""
        # テスト用のモックを設定
        identity = CoreIdentity()
        cache = ResponseCache()
        
        # テストデータ
        test_input = "テストメッセージ"
        test_context = {"session_id": "test123"}
        
        # 初回実行（キャッシュミス）
        response1 = generate_response(test_input, test_context)
        self.assertIsNotNone(response1)
        
        # 2回目（キャッシュヒット）
        response2 = generate_response(test_input, test_context)
        self.assertEqual(response1, response2)
        
        # キャッシュ統計の確認
        stats = cache.get_stats()
        self.assertGreaterEqual(stats['hits'], 1)
        self.assertGreaterEqual(stats['hit_rate'], 0.0)


if __name__ == '__main__':
    unittest.main()
```

## 9. デプロイメント

### 9.1 要件
- Python 3.8+
- 依存ライブラリ: 標準ライブラリのみで動作

### 9.2 設定
```python
# config.py
class Config:
    # キャッシュ設定
    CACHE_SIZE = 1000
    
    # セーフティ設定
    SAFETY_FILTER_ENABLED = True
    
    # ロギング設定
    LOG_LEVEL = "INFO"
    LOG_FILE = "app.log"
```

## 9. テスト

### 9.1 単体テスト
```python
import unittest

class TestCoreIdentity(unittest.TestCase):
    def test_identity_initialization(self):
        identity = CoreIdentity()
        self.assertEqual(identity.version, "5.3")
        self.assertIn("データサイエンス", identity.persona["expertise"])

class TestErrorHandler(unittest.TestCase):
    def test_error_handling(self):
        response = ErrorHandler.handle_error(
            ErrorTypes.OUT_OF_SCOPE,
            topic="料理",
            related_topics="プログラミングやデータサイエンス"
        )
        self.assertIn("料理", response)
        self.assertIn("プログラミング", response)

if __name__ == "__main__":
    unittest.main()
```

## 10. ライセンス

MIT License
